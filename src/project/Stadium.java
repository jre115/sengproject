package project;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;

/**
 * The stadium class represents a stadium in the game environment
 * It manages the current matches available for the week based on the game difficulty and current week.
 * @author jordan redfern
 *
 */
public class Stadium {
	
	/**
	 * The current week in the game
	 */
    int currentWeek;
    
    /**
     * The multiplier based on the difficulty of the game
     */
    double difficultyMultiplier;
    
    /**
     * The divider based on the difficulty of the game
     */
    double difficultyDivider;
    
    /**
     * The user/player's team
     */
    Team playerTeam;
    
    /**
     * A list of team names available for a new match
     */
    ArrayList<String> teamNames;
    
    /**
     * The list of matches available for the week
     */
    ArrayList<Match> matches;
    
    /**
     * Creates a new stadium with the specified game difficulty;
     * If the difficulty is set to Normal - the difficulty multiplier is set to 1.15 and the difficulty divider is set to 2
     * If the difficulty is set to Hard, the difficulty multiplier is set to 1 and the difficulty divider is set to 1.7
     * @param difficulty the game difficulty level
     */
    public Stadium(String difficulty) {
    	currentWeek = 0;
    	playerTeam = new Team();
    	matches = new ArrayList<Match>();
    	teamNames = new ArrayList<String>();
		if (difficulty == "Normal") {
			difficultyMultiplier = 1.15;
			difficultyDivider = 2;
		} else {
			difficultyMultiplier = 1;
			difficultyDivider = 1.7;
		}
    }
    
    /**
     * Sets the stadium with the specified team and current week
     * It updates the current week and player team, and refreshes the stadium matches
     * @param team the player/user's team
     * @param currentWeek the current week of the game
     */
	public void setStadium(Team team, int currentWeek) {
		this.currentWeek = currentWeek;
		playerTeam = team;
		refreshStadiumMatches();
		
	}
	
	/**
	 * retrieves a random team name from the available team names.
	 * If the list of team names is empty, it sets the list with the set of predefined names
	 * @return a random team name
	 */
	public String getTeamName() {
		
		if (teamNames.size() == 0) {
			String[] nameOptions = {"Phoenix Blaze", "Crimson Crests", "Team Thunder", "Mavericks", "Enchanters", 
		            "Fire Flyers", "Golden Owls", "Strong Storms", "Red Raptors", "Velvet Vixens", 
		            "Blackwings", "Broomhounds", "Crestbreakers", "Darkblades", "Dragonscales", "Firewings", 
		            "Goldenrods", "Lightningbolts", "Nightshades", "Phoenixflames", "Redravens", "Shadowcasters", 
		            "Silverstreaks", "Stormchasers", "Thunderclaps", "Cobalt Chasers", "Azure Arrows", "Cobalt Comets", 
		            "Emerald Eagles", "Gilded Greys", "Onyx Owls", "Silver Seekers", "Golden Griffins", 
		            "Ruby Raptors", "Sapphire Suns", "Tornadoes", "Jade Jinxes", "Amethyst Aces", 
		            "Diamond Drakes", "Obsidian Ogres", "Skyriders", "Comet Chasers", "Blazing Flames", "Scarlet Crests",
		            "Emerald Charm", "Mystic Magic", "Velvet Flames", "Crimson Break", "Dark Wings", "Icy Flyers"};
			teamNames = new ArrayList<String>();
			
		    for (String name : nameOptions) {
		        teamNames.add(name);
		    }
			
		}
		
		Random random = new Random();
		String randomName = teamNames.get(random.nextInt(teamNames.size() - 1));
		
		return randomName;
		
	}
	
	/**
	 * Removes the selected match from the list of matches and removes the opposition team name from the list of team names
	 * Name is removed so that each team is only played once during a game.
	 * @param match the match to be removed
	 */
	public void playMatch(Match match) {
		teamNames.remove(match.getOppositionTeamName());
		matches.remove(match);
	}
	
	
	/**
	 * Generates an easy opposition team for a match.
	 * An easy team is generated by creating 2 athletes, setting their statistics based on the offensive score of the player team and setting them as attackers in the opposition team,
	 * and two athletes and setting them based on the defensive team score of the player team and setting the two athletes as defenders in the opposition team.
	 * This should generate a caliber of opposition players that is similar to the player's team.
	 * The money and points for prize in the match are based on the difficulty divider and multiplier from the game's set difficulty.
	 * @return the generated match object, which includes the opposition team and money and points reward
	 */
	public Match generateEasyOpposition() {
		Team oppositionTeam = new Team();
		oppositionTeam.setTeamName(getTeamName());

		for (int i = 0 ; i < 4 ; i ++) {
			Athlete athlete = new Athlete();
			if (i < 2) {
				athlete.setAthleteStatisticsBasedOnOffensive(playerTeam.getOffensiveScore());
				oppositionTeam.addToInitialTeam(athlete, "Attacker");
			} else {
				athlete.setAthleteStatisticsBasedOnDefensive(playerTeam.getDefensiveScore());
				oppositionTeam.addToInitialTeam(athlete, "Defender");
			}
			
			
		}
		Random rand = new Random();
		
		int minMoneyVal = 500;
		int maxMoneyVal = 1500;
		int moneyVal = (int) Math.round((rand.nextInt(maxMoneyVal - minMoneyVal + 1) + minMoneyVal)
                * difficultyMultiplier * (0.95 + currentWeek * 0.01));
		
		int points = (int) (oppositionTeam.getTeamScore() / difficultyDivider);

		Match match = new Match(playerTeam, oppositionTeam, moneyVal, points);
		
		return match;
	}
	
	/**
	 * Generates a medium-level opposition team for a match.
	 * The opposition team is created by generating new athletes, if their offensive score is higher than their defensive score they are set as an attacker and vice versa.
	 * The athlete's statistics are then increased using the current week as a multiplier to ensure matches are increasing in difficulty as the game progresses
	 * The money and points for prize in the match are based on the difficulty divider and multiplier from the game's set difficulty.
	 * @return the generated match object, which includes the opposition team and money and points reward
	 */
	public Match generateMediumOpposition() {
		Team oppositionTeam = new Team();
		oppositionTeam.setTeamName(getTeamName());
				
		int attackerCount = 0;
	    int defenderCount = 0;

	    while (attackerCount < 2 || defenderCount < 2) {
	        Athlete athlete = new Athlete();
	        athlete.increaseStatistics(0.95 + (currentWeek * 0.05));

	        if (athlete.getDefensive() > athlete.getOffensive()) {
	            if (defenderCount < 2) {
	                oppositionTeam.addToInitialTeam(athlete, "Defender");
	                defenderCount++;
	            }
	        } else {
	            if (attackerCount < 2) {
	                oppositionTeam.addToInitialTeam(athlete, "Attacker");
	                attackerCount++;
	            }
	        }
	    }
		
		Random rand = new Random();
		
		int minMoneyVal = 1000;
		int maxMoneyVal = 2000;
		int moneyVal = (int) Math.round((rand.nextInt(maxMoneyVal - minMoneyVal + 1) + minMoneyVal)
                * difficultyMultiplier * (0.95 + currentWeek * 0.01));
		
		int points = (int) (oppositionTeam.getTeamScore() / difficultyDivider);
		
		Match match = new Match(playerTeam, oppositionTeam, moneyVal, points);
		
		return match;

	}
	
	/**
	 * Generates a difficulty-level opposition team for a match.
	 * The opposition team is created by generating new athletes, if their offensive score is higher than their defensive score they are set as an attacker and vice versa.
	 * The athlete's statistics are then increased using the current week as a multiplier to ensure matches are increasing in difficulty as the game progresses
	 * Note that the increase statistics multiplier is higher than the one in generateMediumOpposition() to ensure the opposition team is more challenging
	 * The money and points for prize in the match are based on the difficulty divider and multiplier from the game's set difficulty. 
	 * The reward from a difficult match is higher than that of a medium or easy match
	 * @return the generated match object, which includes the opposition team and money and points reward
	 */
	public Match generateDifficultOpposition() {
		Team oppositionTeam = new Team();
		oppositionTeam.setTeamName(getTeamName());
		
		int attackerCount = 0;
	    int defenderCount = 0;
	    
	    while (attackerCount < 2 || defenderCount < 2) {
	        Athlete athlete = new Athlete();
	        athlete.increaseStatistics(1.1 + (currentWeek * 0.05));

	        if (athlete.getDefensive() > athlete.getOffensive()) {
	            if (defenderCount < 2) {
	                oppositionTeam.addToInitialTeam(athlete, "Defender");
	                defenderCount++;
	            }
	        } else {
	            if (attackerCount < 2) {
	                oppositionTeam.addToInitialTeam(athlete, "Attacker");
	                attackerCount++;
	            }
	        }
	    }
	    

		Random rand = new Random();
		
		int minMoneyVal = 1500;
		int maxMoneyVal = 2500;
		int moneyVal = (int) Math.round((rand.nextInt(maxMoneyVal - minMoneyVal + 1) + minMoneyVal)
                * difficultyMultiplier * (0.95 + currentWeek * 0.01));
		
		int points = (int) (oppositionTeam.getTeamScore() / difficultyDivider);

		Match match = new Match(playerTeam, oppositionTeam, moneyVal, points);
		
		return match;

	}
	
	/**
	 * Refreshes the stadium options for matches (matchOptions) by generating new match options.
	 * The method randomly selects between 1 and 2 easy matches and 1 difficult opposition.
	 * If there is only 1 easy match, a medium match will be generated. 
	 */
    public void refreshStadiumMatches() {
    	
    	Random rand = new Random();
    	ArrayList<Match> matchOptions = new ArrayList<Match>();
    	
    	int numOfEasyMatches = rand.nextInt(2) + 1;
    	
    	for (int i = 0 ; i < numOfEasyMatches ; i ++) {
    		matchOptions.add(generateEasyOpposition());
    	}
    	if (numOfEasyMatches == 1) {
    		matchOptions.add(generateMediumOpposition());
    	}
    	
    	matchOptions.add(generateDifficultOpposition());
    	
    	matches = matchOptions;
    	
    }
    
    /**
     * Returns the current matches available.
     * Note: The currentPlayerTeam parameter is directly used within the game environment, 
     * so there is no need to refresh the team from when matches were refreshed.
     * @return list of match objects representing the available matches to play for the current week
     */
    public ArrayList<Match> getMatches() {
    	return matches;
    }
   
}
